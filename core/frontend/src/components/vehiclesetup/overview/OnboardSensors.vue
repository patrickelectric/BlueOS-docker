<template>
  <v-card class="ma-2">
    <v-card-title class="align-center">
      Autopilot Sensors
    </v-card-title>
    <v-card-text>
      <v-simple-table dense>
        <template #default>
          <thead>
            <tr>
              <th class="text-left">
                Sensor
              </th>
              <th class="text-left">
                Type
              </th>
              <th class="text-left">
                Bus
              </th>
              <th class="text-left">
                Address
              </th>
              <th class="text-left">
                Status
              </th>
            </tr>
          </thead>
          <tbody>
            <tr
              v-for="(sensor, index) in sensors"
              :key="`${sensor.deviceName}-${index}`"
            >
              <td><b>{{ sensor.deviceName ?? 'UNKNOWN' }}</b></td>
              <td v-tooltip="sensor.typeTooltip">
                {{ sensor.type }}
              </td>
              <td>{{ sensor.bus }}</td>
              <td>{{ sensor.address }}</td>
              <td>
                <nobr v-if="typeof sensor.status == 'string'">
                  {{ sensor.status }}
                </nobr>
                <nobr v-else>
                  <v-icon
                    v-if="sensor.status.calibrated"
                    v-tooltip="'Sensor is callibrated and good to use'"
                    color="green"
                  >
                    mdi-emoticon-happy-outline
                  </v-icon>
                  <v-icon
                    v-else
                    v-tooltip="'Sensor needs to be calibrated'"
                    color="red"
                  >
                    mdi-emoticon-sad-outline
                  </v-icon>
                  <nobr v-if="sensor.status.thermometerCalibrated !== undefined">
                    <v-icon
                      v-if="sensor.status.thermometerCalibrated"
                      v-tooltip="'Sensor thermometer is calibrated and good to use'"
                      color="green"
                    >
                      mdi-thermometer-check
                    </v-icon>
                    <v-icon
                      v-else
                      v-tooltip="'Sensor thermometer needs to be calibrated'"
                      color="red"
                    >
                      mdi-thermometer-off
                    </v-icon>
                  </nobr>
                </nobr>
              </td>
            </tr>
          </tbody>
        </template>
      </v-simple-table>
    </v-card-text>
  </v-card>
</template>

<script lang="ts">
import Vue from 'vue'

import autopilot_data from '@/store/autopilot'
import autopilot from '@/store/autopilot_manager'
import mavlink from '@/store/mavlink'
import { printParam } from '@/types/autopilot/parameter'
import { Dictionary } from '@/types/common'
import decode, { deviceId } from '@/utils/deviceid_decoder'
import mavlink_store_get from '@/utils/mavlink'

interface SensorCalibrationStatus {
  calibrated: boolean,
  thermometerCalibrated?: boolean,
}

interface SensorInfo {
  deviceName: string,
  type: string,
  bus: string,
  address: string,
  status: SensorCalibrationStatus | string
}

export default Vue.extend({
  name: 'OnboardSensors',
  computed: {
    sensors(): SensorInfo[] {
      const imus = this.imus.map((imu) => ({
        deviceName: imu.deviceName,
        type: 'INS',
        typeTooltip: 'Inertial Navigation Sensor',
        bus: `${imu.busType} ${imu.bus}`,
        address: `0x${imu.address}`,
        status: {
          calibrated: this.imu_is_calibrated[imu.param],
          thermometerCalibrated: this.imu_temperature_is_calibrated[imu.param],
        },
      }))

      const compasses = this.compasses.map((compass) => ({
        deviceName: compass.deviceName,
        type: this.compass_description[compass.param],
        typeTooltip: 'Inertial Navigation Sensor',
        bus: `${compass.busType} ${compass.bus}`,
        address: `0x${compass.address}`,
        status: {
          calibrated: this.compass_is_calibrated[compass.param],
          thermometerCalibrated: undefined,
        },
      }))

      const baros = this.baros.map((baro) => ({
        deviceName: baro.deviceName,
        type: `${this.get_pressure_type[baro.param]} Pressure`,
        typeTooltip: 'Inertial Navigation Sensor',
        bus: `${baro.busType} ${baro.bus}`,
        address: `0x${baro.address}`,
        status: this.baro_status[baro.param],
      }))

      return [...imus, ...compasses, ...baros]
    },
    imus() : deviceId[] {
      return autopilot_data.parameterRegex('^INS_ACC.*_ID')
        .filter((param) => param.value !== 0)
        .map((parameter) => decode(parameter.name, parameter.value))
    },
    compasses(): deviceId[] {
      return autopilot_data.parameterRegex('^COMPASS_DEV_ID.*')
        .filter((param) => param.value !== 0)
        .map((parameter) => decode(parameter.name, parameter.value))
    },
    baros(): deviceId[] {
      return autopilot_data.parameterRegex('^BARO.*_DEVID')
        .filter((param) => param.value !== 0)
        .map((parameter) => decode(parameter.name, parameter.value))
    },
    compass_description(): Dictionary<string> {
      const results = {} as Dictionary<string>
      for (const compass of this.compasses) {
        // First we check the priority for this device
        let priority = 'Unused'
        let number_in_parameter = 0
        for (const param of autopilot_data.parameterRegex('^COMPASS_PRIO.*_ID')) {
          if (param.value === compass.paramValue) {
            const number_in_parameter_as_string = param.name.match(/\d+/g)?.[0] ?? '1'
            number_in_parameter = parseInt(number_in_parameter_as_string, 10)
            switch (number_in_parameter) {
              case 1:
                priority = '1st'
                break
              case 2:
                priority = '2nd'
                break
              case 3:
                priority = '3rd'
                break
              default:
                priority = 'Unused'
            }
          }
        }
        // Then we check if it is internal or external
        const extern_param_name = number_in_parameter === 1
          ? 'COMPASS_EXTERNAL' : `COMPASS_EXTERN${number_in_parameter}`
        const external = autopilot_data.parameter(extern_param_name)?.value === 1 ?? false
        const external_string = external ? 'external' : 'internal'
        results[compass.param] = `${priority} Compass (${external_string})`
      }
      return results
    },
    compass_is_calibrated(): Dictionary<boolean> {
      const results = {} as Dictionary<boolean>
      for (const compass of this.compasses) {
        const compass_number = compass.param.split('COMPASS_DEV_ID')[1]
        const offset_params_names = [
          `COMPASS_OFS${compass_number}_X`,
          `COMPASS_OFS${compass_number}_Y`,
          `COMPASS_OFS${compass_number}_Z`,
        ]
        const diagonal_params_names = [
          `COMPASS_ODI${compass_number}_X`,
          `COMPASS_ODI${compass_number}_Y`,
          `COMPASS_ODI${compass_number}_Z`,
        ]

        const offset_params = offset_params_names.map(
          (name) => autopilot_data.parameter(name),
        )
        const diagonal_params = diagonal_params_names.map(
          (name) => autopilot_data.parameter(name),
        )
        if (offset_params.includes(undefined) || diagonal_params.includes(undefined)) {
          results[compass.param] = false
          continue
        }
        const scale_param_name = `COMPASS_SCALE${compass_number}`
        const scale_param = autopilot_data.parameter(scale_param_name)
        const is_at_default_offsets = offset_params.every((param) => param?.value === 0.0)
        const is_at_default_diagonals = diagonal_params.every((param) => param?.value === 0.0)
        results[compass.param] = offset_params.isEmpty() || diagonal_params.isEmpty()
          || !is_at_default_offsets || !is_at_default_diagonals || scale_param?.value !== 0.0
      }
      return results
    },
    imu_is_calibrated(): Dictionary<boolean> {
      const results = {} as Dictionary<boolean>
      for (const imu of this.imus) {
        const param_radix = imu.param.split('_ID')[0]
        const offset_params_names = [`${param_radix}OFFS_X`, `${param_radix}OFFS_Y`, `${param_radix}OFFS_Z`]
        const scale_params_names = [`${param_radix}SCAL_X`, `${param_radix}SCAL_Y`, `${param_radix}SCAL_Z`]
        const offset_params = offset_params_names.map(
          (name) => autopilot_data.parameter(name),
        )
        const scale_params = scale_params_names.map(
          (name) => autopilot_data.parameter(name),
        )
        const is_at_default_offsets = offset_params.every((param) => param?.value === 0.0)
        const is_at_default_scale = scale_params.every((param) => param?.value === 1.0)
        results[imu.param] = offset_params.isEmpty() || scale_params.isEmpty()
        || !is_at_default_offsets || !is_at_default_scale
      }
      return results
    },
    imu_temperature_is_calibrated(): Dictionary<boolean> {
      const results = {} as Dictionary<boolean>
      for (const imu of this.imus) {
        let param_radix = imu.param.split('_ID')[0]
        // CALTEMP parameters contains ID for the first sensor, _ID does not, so we need to add it
        if (!/\d$/.test(param_radix)) {
          param_radix += '1'
        }
        const name = `${param_radix}_CALTEMP`
        const parameter = autopilot_data.parameter(name)
        results[imu.param] = parameter !== undefined && parameter.value !== -300
      }
      return results
    },
    is_water_baro(): Dictionary<boolean> {
      const results = {} as Dictionary<boolean>
      for (const compass of this.compasses) {
        if (['MS5837', 'MS5611', 'KELLERLD'].includes(compass.deviceName ?? '--')
        && autopilot.vehicle_type === 'Submarine') {
          results[compass.param] = true
        }
        results[compass.param] = false
      }
      return results
    },
    baro_status(): Dictionary<string> {
      const results = {} as Dictionary<string>
      for (const baro of this.baros) {
        const radix = baro.param.replace('_DEVID', '')
        const number = parseInt(radix.replace('BARO', ''), 10)
        if (this.is_water_baro[baro.param]) {
          const value = mavlink_store_get(mavlink, 'VFR_HUD.messageData.message.alt') as number
          results[baro.param] = `${value ? value.toFixed(2) : '--'} m`
        }
        const msg = number === 1 ? 'SCALED_PRESSURE' : `SCALED_PRESSURE${number}`
        const value = mavlink_store_get(mavlink, `${msg}.messageData.message.press_abs`) as number
        results[baro.param] = `${value ? value.toFixed(2) : '--'} hPa`
      }
      return results
    },
    get_pressure_type(): Dictionary<string> {
      const results = {} as Dictionary<string>
      for (const barometer of this.baros) {
        if (!this.is_water_baro[barometer.param]) {
          results[barometer.param] = 'Barometric'
        }
        const spec_gravity_param = autopilot_data.parameter('BARO_SPEC_GRAV')
        results[barometer.param] = printParam(spec_gravity_param)
      }
      return results
    },
  },
  mounted() {
    mavlink.setMessageRefreshRate({ messageName: 'SCALED_PRESSURE$', refreshRate: 1 })
    mavlink.setMessageRefreshRate({ messageName: 'SCALED_PRESSURE2$', refreshRate: 1 })
    mavlink.setMessageRefreshRate({ messageName: 'VFR_HUD', refreshRate: 1 })
  },
  methods: {

  },
})
</script>
